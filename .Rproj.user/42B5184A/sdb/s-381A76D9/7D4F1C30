{
    "collab_server" : "",
    "contents" : "# Simple wrapper for easy formatted printing to screen. outer invisible may be unnecessary (http://stackoverflow.com/questions/13023274/how-to-do-printf-in-r)\nprintf <- function(...) invisible(print(sprintf(...)))\n\nloadRenderTranslateSql2 <- function(sqlFilename, packageName, dbms = \"sql server\", ...,\n                                   oracleTempSchema = NULL) {\n\n  pathToSql <- system.file(paste(\"sql/\", gsub(\" \", \"_\", dbms),\n                                 sep = \"\"), sqlFilename, package = packageName)\n  mustTranslate <- !file.exists(pathToSql)\n  if (mustTranslate) {\n    pathToSql <- system.file(paste(\"sql/\", \"sql_server\",\n                                   sep = \"\"), sqlFilename, package = packageName)\n  }\n  parameterizedSql <- readChar(pathToSql, file.info(pathToSql)$size)\n  renderedSql <- renderSql(parameterizedSql[1], ...)$sql\n  if (mustTranslate)\n    renderedSql <- translateSql(renderedSql, \"sql server\",\n                                dbms, oracleTempSchema)$sql\n  renderedSql\n}\n\ncreateCohort <- function(connection, connectionDetails, cdm_schema, target_schema, target_table){\n\n  sql <- loadRenderTranslateSql2(\"createCohort_parameterized.sql\",\"OHDSIDeriveVariables\",\n                                cdm_schema = cdm_schema,\n                                dbms = connectionDetails$dbms,\n                                target_schema = target_schema,\n                                target_table = target_table,\n                                study_start_yyyymmdd = '20111201',\n                                study_end_yyyymmdd = '20141231')\n\n  executeSql(connection, sql)\n}\n\n#'\ngetCohort <- function(connectionDetails, cdm_schema, target_schema, target_table){\n    # pathToSql <- system.file(paste(\"sql/\", gsub(\" \", \"_\", connectionDetails$dbms),\n    #                                sep = \"\"), \"getCohort_parameterized.sql\", package = \"DrugAnalysis\")\n    # print(pathToSql)\n    # mustTranslate <- !file.exists(pathToSql)\n    # print(mustTranslate)\n    # print(file.info(pathToSql))\n    # print(list.files())\n    # sql <- readSql(\"inst/sql/sql_server/getCohort_parameterized.sql\")\n    # print(sql)\n\n    ## Get dataframe with the study cohort\n    sql <- loadRenderTranslateSql2(\"getCohort_parameterized.sql\",\"OHDSIDeriveVariables\",\n                     cdm_schema = connectionDetails$schema,\n                     dbms = connectionDetails$dbms,\n                     target_schema = target_schema,\n                     target_table = target_table)\n\n    connection <- connect(connectionDetails)\n    result_df <- querySql(connection, sql)\n\n    ## Translations from index to names\n    # Riva or VKA to human readable classifications.\n    result_df$RIVA_OR_VKA_STRING <- as.factor( result_df$RIVA_OR_VKA )\n    levels( result_df$RIVA_OR_VKA_STRING ) <- list('Warfarin + Phenprocoumon'=0, 'Rivaroxaban'=1)\n\n    # Naive/non-naive\n    result_df$IS_NAIVE_STRING <- as.factor(result_df$IS_NAIVE)\n    levels(result_df$IS_NAIVE_STRING) <- list('Non-naive'=0,'OAC Naive'=1)\n\n    # TODO: translate by join to concept table (concept_name)\n    # Switchto #todo: expande with other ids that can be used for these.\n    result_df$SWITCHTO_STRING <- as.factor(result_df$SWITCHTO)\n    levels( result_df$SWITCHTO_STRING ) <- list(\"Warfarin\"=1310149,\"Phenprocoumon\"=19035344,\"Dabigatran\"=40228152,\n                                              \"Rivaroxaban\"=40241331,\"Apixaban\"=43013024)\n    # Gender\n    result_df$GENDER_STRING <- as.factor(result_df$GENDER_CONCEPT_ID)\n    levels(result_df$GENDER_STRING) <- list('Male'=8507,'Female'=8532,'Unknown'=8551)\n\n    # Background\n    result_df$BACKGROUND_STRING <- as.factor(result_df$BACKGROUND)\n    levels(result_df$BACKGROUND_STRING) <- list('Native'=43021808,'Immigrant'=NA)\n\n    return(result_df)\n}\n\ngetAgeAtIndex <- function( studyPop ){\n  # Calculate age at index from index date and year of birth.\n  # This approximation can be a year less than the real age, because month and day fo birth ar missing.\n  indexYear <- as.numeric( format(studyPop$INDEX_DATE, \"%Y\") )\n  return( indexYear - as.numeric( studyPop$YEAR_OF_BIRTH ) )\n}\n\ngetHistory_ <- function( type, concept_ids, connectionDetails,\n                         target_schema, target_table ){\n  ###\n  # Determines which persons in the cohort have a history of the given concepts.\n  # Type is either 'condition', 'procedure' or 'drug'.\n  # Returns a vector of 1 and 0.\n  # IMPORTANT: relies on sorting on person_id for returning in the same order as dataframe.\n  ###\n\n  # Parse the concept codes and choose sql file\n  if ( type== 'condition' ){\n    concept_ids_string <- paste(concept_ids,collapse = \",\")\n    sql <- readSql(\"sql/history_condition_parameterized.sql\")\n\n  } else if ( type == 'procedure' ){\n    concept_ids_string <- paste(concept_ids,collapse = \",\")\n    sql <- readSql(\"sql/history_procedure_parameterized.sql\")\n\n  } else if ( type == 'drug' ){\n    atc_codes_string <- paste( concept_ids, collapse = \"' OR atc.concept_code LIKE '\" )\n    concept_ids_string <- paste( \"(atc.concept_code LIKE '\",atc_codes_string,\"')\", sep=\"\" )\n    sql <- readSql(\"sql/history_drug_parameterized.sql\")\n  }\n\n  sql <- renderSql(sql,\n                   cdm_schema = connectionDetails$schema,\n                   target_schema = target_schema,\n                   target_table = target_table,\n                   concept_ids = concept_ids_string)$sql\n  sql <- translateSql(sql, targetDialect = connectionDetails$dbms)$sql\n\n  connection <- connect(connectionDetails)\n  result_df <- querySql(connection, sql)\n\n  #TODO: extra check that the vector is returned in the right order?\n  return( result_df$CONCEPT_HISTORY )\n}\n\ngetPriorConditionBool <- function( concept_ids, connectionDetails, target_schema, target_table ){\n  return ( getHistory_('condition', concept_ids, connectionDetails, target_schema, target_table ) )\n}\n\ngetProcedureHistory <- function( concept_ids, connectionDetails, target_schema, target_table ){\n  return ( getHistory_('procedure', concept_ids, connectionDetails, target_schema, target_table ) )\n}\n\ngetPriorDrugBool_byATC <- function( atcCodes, connectionDetails, target_schema, target_table ) {\n  return ( getHistory_('drug', atcCodes, connectionDetails, target_schema, target_table ) )\n}\n\ngetAtIndexDrugBool_byATC <- function(atcCodes, connectionDetails, cohortDatabaseSchema, cohortTableName, useIn = FALSE) {\n  # Only set useIn to true if this gives a performance boost.\n  # Parse the atc codes\n  if (useIn){\n    atc_codes_string <- paste(atcCodes,collapse = \"','\")\n    atc_codes_string <- paste(\"atc.concept_code IN ('\",atc_codes_string,\"')\", sep=\"\")\n  } else {\n    atc_codes_string <- paste( atcCodes, collapse = \"' OR atc.concept_code LIKE '\" )\n    atc_codes_string <- paste( \"(atc.concept_code LIKE '\",atc_codes_string,\"')\", sep=\"\" )\n  }\n\n  sql <- readSql(\"sql/new_drug_parameterized.sql\")\n  sql <- renderSql(sql,\n                   cdm_schema = connectionDetails$schema,\n                   target_schema = cohortDatabaseSchema,\n                   target_table = cohortTableName,\n                   where_clause = atc_codes_string)$sql\n  sql <- translateSql(sql, targetDialect = connectionDetails$dbms)$sql\n\n  connection <- connect(connectionDetails)\n  result_df <- querySql(connection, sql)\n\n  #TODO: extra check that the vector is returned in the right order?\n  return( result_df$DRUG_NEW )\n}\n\ngetDaysAtRisk_ <- function(type, concept_ids, connectionDetails, target_schema, target_table,\n                           days_correction = 30, study_end_yyyymmdd = '20141231') {\n\n  if (type == 'death') {\n     # Either main cause or a secondary cause of death.\n     cause_ids_string <- paste(concept_ids, collapse = \",\")\n     where_string <- paste(\"(cause_concept_id IN (\",cause_ids_string,\n                               \") OR value_as_concept_id IN (\",cause_ids_string,\") )\", sep=\"\")\n     sql <- readSql(\"sql/days_at_risk_death_parameterized.sql\")\n\n  } else if (type == 'condition') {\n    concept_ids_string <- paste(concept_ids, collapse = \",\")\n    # Concept id in given ids AND\n    # Not a Secondary condition (Primary and first place condition are allowed)\n    where_string <- paste(\"condition_concept_id IN (\", concept_ids_string,\n                         \") AND condition_type_concept_id != 44786629\", sep=\"\")\n    sql <- readSql(\"sql/days_at_risk_condition_parameterized.sql\")\n\n  } else {\n    printf(\"%s days at risk is not supported\", type)\n    exit(1)\n  }\n\n  # If no vector is given (e.g. boolean), then all conepts are allowed.\n  # This overwrites any where_string created\n  if ( concept_ids[1] == FALSE ){\n    where_string <- \"True\"\n  }\n\n\n  sql <- renderSql(sql,\n                   cdm_schema = connectionDetails$schema,\n                   target_schema = target_schema,\n                   target_table = target_table,\n                   where_clause = where_string,\n                   days_correction = days_correction,\n                   study_end_date = study_end_yyyymmdd)$sql\n  sql <- translateSql(sql, targetDialect = connectionDetails$dbms)$sq\n  connection <- connect(connectionDetails)\n\n  result_df <- querySql(connection, sql)\n  return( result_df )\n}\n\ngetDeathDaysAtRisk <- function(cause_ids, connectionDetails, target_schema, target_table,\n                               days_correction = 30, study_end_yyyymmdd = '20141231') {\n  return( getDaysAtRisk_('death', cause_ids, connectionDetails, target_schema, target_table,\n                         days_correction, study_end_yyyymmdd) )\n}\n\ngetConditionDaysAtRisk <- function(condition_ids, connectionDetails, target_schema, target_table,\n                               days_correction = 30, study_end_yyyymmdd = '20141231') {\n  return( getDaysAtRisk_('condition', condition_ids, connectionDetails, target_schema, target_table,\n                         days_correction, study_end_yyyymmdd) )\n}\n\ngetConditionConcomitant <- function(condition_ids, connectionDetails, target_schema, target_table ){\n    ## Boolean conditions 'at index': occurrence both before and after index\n    ## Implementation using exiting functions instead of new sql\n\n    # Get all histories of this condition\n    occurrenceBeforeIndex <- getPriorConditionBool(condition_ids, connectionDetails, target_schema, target_table)\n\n    # Get all after index of this condition\n    conditionRisk <- getConditionDaysAtRisk(condition_ids, connectionDetails, target_schema, target_table,\n                                            days_correction = 0)\n    occurrenceAfterIndex <- conditionRisk$CENSOR\n\n    # If a True if condition occurred both before and after index.\n    result <- occurrenceBeforeIndex * occurrenceAfterIndex\n\n    printf( \"Total Number of patients with occurrences before index: %d\", sum(occurrenceBeforeIndex) )\n    printf( \"Total Number of patients with occurrences after index: %d\", sum(occurrenceAfterIndex) )\n    printf( \"Total Number of patients with occurrences before and after index: %d\", sum(result) )\n\n    return(result)\n}\n",
    "created" : 1468233275550.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3817766331",
    "id" : "7D4F1C30",
    "lastKnownWriteTime" : 1468236604,
    "last_content_update" : 1468236604301,
    "path" : "~/Documents/OHDSIDeriveVariables/R/getDataFunctions.R",
    "project_path" : "R/getDataFunctions.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}